\documentclass{beamer}
\usepackage{beamerthemeshadow}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{color}
\usepackage{setspace}
\usepackage{array}
\usepackage[USenglish]{babel}
\usepackage[useregional]{datetime2}
\usepackage{tikz}
\usepackage{tikz-qtree}
%\usepackage[demo]{graphicx}
\usepackage{subcaption}

\DTMlangsetup[en-US]{showdayofmonth=false}

\definecolor{Code}{rgb}{0,0,0}
\definecolor{Decorators}{rgb}{0.5,0.5,0.5}
\definecolor{Numbers}{rgb}{0.5,0,0}
\definecolor{MatchingBrackets}{rgb}{0.25,0.5,0.5}
\definecolor{Keywords}{rgb}{0,0,1}
\definecolor{self}{rgb}{0,0,0}
\definecolor{Strings}{rgb}{0,0.63,0}
\definecolor{Comments}{rgb}{0,0.63,1}
\definecolor{Backquotes}{rgb}{0,0,0}
\definecolor{Classname}{rgb}{0,0,0}
\definecolor{FunctionName}{rgb}{0,0,0}
\definecolor{Operators}{rgb}{0,0,0}
\definecolor{Background}{rgb}{0.98,0.98,0.98}

% Tables
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

% Language 
\lstdefinelanguage{Python}{
numbers=left,
numberstyle=\footnotesize,
numbersep=1em,
xleftmargin=1em,
framextopmargin=2em,
framexbottommargin=2em,
showspaces=false,
showtabs=false,
showstringspaces=false,
frame=l,
tabsize=4,
% Basic
basicstyle=\ttfamily\small\setstretch{1},
backgroundcolor=\color{Background},
% Comments
commentstyle=\color{Comments}\slshape,
% Strings
stringstyle=\color{Strings},
morecomment=[s][\color{Strings}]{"""}{"""},
morecomment=[s][\color{Strings}]{'''}{'''},
% keywords
morekeywords={import,from,class,def,for,while,if,is,in,elif,else,not,and,or,print,break,continue,return,True,False,None,access,as,,del,except,exec,finally,global,import,lambda,pass,print,raise,try,assert},
keywordstyle={\color{Keywords}\bfseries},
% additional keywords
morekeywords={[2]@invariant,pylab,numpy,np,scipy},
keywordstyle={[2]\color{Decorators}\slshape},
emph={self},
emphstyle={\color{self}\slshape},
%
}

\title[Title inside foot page] %optional
{Title}
 
\subtitle{Workshop}
 
\author[JGM] % (optional, for multiple authors)
{Ing.~Gómez~Marín,~Jaime}
 
\institute[TECSUP] % (optional)
{
  
    TdG Department
}
 
\date{\today} 

\logo{\centering \includegraphics[height=0.8cm]{img/tecsup.png}}

\begin{document}
\begin{frame}
\titlepage
\end{frame}

% Index
\begin{frame}
\frametitle{Table of Contents}
\begin{itemize}
\item Introduction
\item Recursion
\begin{itemize}
\item Recursion Function
\item Factorial Function
\item Recursion and Memory
\item Recursion versus Iteration
\item Tower of Hanoi puzzle
\end{itemize}
\item Backtracking
\item Computational complexity of mathematical operations
\item Conclusion
\item Bibliography
\end{itemize}
\end{frame}

% Introduction
\begin{frame}
\frametitle{Introduction}
 
In this session, we will look at one of the important topics,
\alert{recursion} which will be used in almost every session, and also
its relative \alert{backtracking}.

\end{frame}


% What is Recursion
\begin{frame}
\frametitle{What is Recursion?}
\begin{itemize}
\item Any function which \alert{calls ilself} is called recursive.
\item A recursive method solves a problem by calling a copy of itself
to work on a \alert{smaller problem}.
\item The sequence of smaller problems must eventually converge on the \alert{base case}
\end{itemize}
\end{frame}


% Why Recursion?
\begin{frame}
\frametitle{Why Recursion?}
\begin{itemize}
\item Recursion is a useful \alert{ technique} borrowed from mathematics.
\item Recursive code is generally shorter and easier to write than iterative code
\item Generally, loops are turned into recursive functions when they are compiled or
interpreted.
\end{itemize}

\begin{block}{For examples}
Sort, search and traversal problems often have simple recursive solutions.
\end{block}

\end{frame}


% Recursion Function
\begin{frame}
\frametitle{Recursion Function}
\begin{itemize}
\item A recursive function performs a task in part by calling itself to perform the subtasks.
\item When the function does not recur, is called the base case.
\end{itemize}

\begin{block}{Pseudocode}
\begin{algorithmic}
\If{test for the base case}
    \State{return some base case value}
\Else
    \State{return (some work and then a recursive call)}
\EndIf
\end{algorithmic}
\end{block}

\end{frame}

% Example : Factorial Function
\begin{frame}
\frametitle{Example : Factorial Function}
\begin{block}{Definition}
\[
  f(x) =
  \begin{cases}
  	1    		& \text{if $n=0$} \\
      	n*(n-1)! & \text{if $n>=1$} 
  \end{cases}
\]
\end{block}

\begin{block}{Exercise}
Implement a method to get the factorial of a number.
\end{block}

\end{frame}


% Code : Factorial Function
\begin{frame}
\frametitle{Code : Factorial Function}
\lstinputlisting[language=Python]{sourcecode/Factorial.py}
\end{frame}


% Image : Factorial Function
\begin{frame}
\frametitle{Factorial vs Time Processing}
\begin{figure}
\includegraphics[scale=0.5]{img/ch01_factorial_time.png}
\caption{01}
\end{figure}
\end{frame}


% Recursion and Memory
\begin{frame}
\frametitle{Recursion and Memory}
\begin{itemize}
\item Each recursive call makes a new copy of that method (actually only the variables) in memory.
\item Once a method ends (that is, returns some data), the copy of that returning method is removed from memory.
\item The recursive solutions look simple but visualization and tracing takes time.
\end{itemize}
\end{frame}

% Code : Recursion and Memory
\begin{frame}
\frametitle{Code : Recursion and Memory}
\lstinputlisting[language=Python]{sourcecode/RecursionMemory.py}
\end{frame}

% Recursion vs Iteration
\begin{frame}
\frametitle{Recursion versus Iteration}
\begin{itemize}
\item Which way is better? - iteration or recursion? : \alert{Depends on what we are trying to do.}
\item Once a method ends (that is, returns some data), the copy of that returning method is removed from memory.
\item A recursive approach makes it simpler to solve a problem that may not have the most obvious of answers.
\item  But, recursion adds overheacl for each recursive call.
\end{itemize}
\end{frame}

% Recursion vs Iteration
\begin{frame}
\frametitle{Recursion versus Iteration}
\begin{tabular}{|L{5cm}|L{5cm}|}
\hline
\textbf{Recursion} & \textbf{Iteration}  \\
\hline
Terminates when a base case is reached 
& Terminates when a condition is proven lo be false. \\
\hline
Each recursive call require extra space on the stack frame (memory) 
& Each iteration docs not require extra space.  \\
\hline
If we get infinive recursion, the program may run out of memory 
and result in stack overllow.
& An infinite loop could loop forever since there is no extra memory being created.  \\
\hline
Solutions lo some problems are easier lo formulate recursively.
& lterative solutions to a problem may not always be as obvious as a recursive solution. \\
\hline
\end{tabular}
\end{frame}


\begin{frame}
\frametitle{Towers of Hanoi puzzle}
\begin{itemize}
\item Only one disk may be moved at a time.
\item Each move consists of taking the upper disk from one of the rods and sliding it onto another rod, on top
of the other disks that may already be present on that rod.
\item No disk may be placed on top of a smaller disk.
\end{itemize}
\begin{figure}
\includegraphics[scale=0.5]{img/ch01_tower_of_hanoi.jpg}
\caption{02}
\end{figure}
\end{frame}

% Code : Towers of Hanoi puzzle
\begin{frame}
\frametitle{Code : Towers of Hanoi puzzle}
\lstinputlisting[language=Python]{sourcecode/Hanoi.py}
%\lstinputlisting[language=Python, firstline=1, lastline=10]{sourcecode/Hanoi.py}
%\lstinputlisting[language=Python, firstline=5, lastline=10]{sourcecode/Hanoi.py}
%\lstinputlisting[language=Python, firstnumber=2, firstline=1, lastline=10]{sourcecode/Hanoi.py}

\end{frame}


% Image : Towers of Hanoi puzzle
\begin{frame}
\frametitle{Hanoi vs Time Processing}
\begin{figure}
\includegraphics[scale=0.5]{img/ch01_hanoi_time.png}
\caption{03}
\end{figure}
\end{frame}



\begin{frame}
\frametitle{Backtracking}
\begin{itemize}
\item Backtracking is a form or recursion.
\item Sometimes the best algorithm for a problem is to try all possibilities.
\item Backtracking is a recursive algorithm for finding all (or some) solutions to some computational problems.
\end{itemize}

\begin{block}{Exercise}
Generate all the binary strings with n bits.
\end{block}

\end{frame}


% Code : Backtracking
\begin{frame}
\frametitle{Code : Backtracking}
\lstinputlisting[language=Python]{sourcecode/BacktrackingSimple.py}
\end{frame}


\begin{frame}
\frametitle{Computational complexity of mathematical operations}
\begin{figure}
\includegraphics[scale=0.20]{img/ch01_comparison_computational_complexity.png}
\caption{04 : Graphs of functions commonly used in the analysis of algorithms, showing the number of operations N versus input size n for each function}
\end{figure}
\end{frame}


\begin{frame}
\frametitle{Conclusion}
\begin{itemize}
\item Recursion is a programming technique that allows the programmer to express
operations in terms of themselves.
\item Backtracking is a recursive algorithm for finding all (or some) solutions to some computational problems.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Bibliography}

\begin{thebibliography}{0000}
  \bibitem{} Narasimha Karumanchi. Data Structure and Algorithmic - Thinking with Python, 2019.
  \bibitem{} John Wiley \& Sons. Data Structure And Algorithms In Java  internet, 2010.
\end{thebibliography}
\end{frame}


\end{document}